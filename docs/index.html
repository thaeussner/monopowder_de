<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Anna Banzer">
<meta name="author" content="Isotta Bernardoni">
<meta name="author" content="Joël Kocher">
<meta name="author" content="Till Höussner">
<meta name="dcterms.date" content="2024-05-13">

<title>MonoPowder</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


<link rel="stylesheet" href="styles.css">
</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#the-problem" id="toc-the-problem" class="nav-link active" data-scroll-target="#the-problem">The Problem</a></li>
  <li><a href="#our-initial-brainstorming-ideas" id="toc-our-initial-brainstorming-ideas" class="nav-link" data-scroll-target="#our-initial-brainstorming-ideas">Our Initial Brainstorming Ideas</a>
  <ul class="collapse">
  <li><a href="#hand-cycle-setup" id="toc-hand-cycle-setup" class="nav-link" data-scroll-target="#hand-cycle-setup">Hand-Cycle Setup</a></li>
  <li><a href="#rod-assisted-tracks" id="toc-rod-assisted-tracks" class="nav-link" data-scroll-target="#rod-assisted-tracks">Rod-Assisted Tracks</a></li>
  <li><a href="#fully-motorized-tracks" id="toc-fully-motorized-tracks" class="nav-link" data-scroll-target="#fully-motorized-tracks">Fully Motorized Tracks</a></li>
  <li><a href="#adapted-outriggers" id="toc-adapted-outriggers" class="nav-link" data-scroll-target="#adapted-outriggers">Adapted Outriggers</a></li>
  </ul></li>
  <li><a href="#our-solution" id="toc-our-solution" class="nav-link" data-scroll-target="#our-solution">Our Solution</a></li>
  <li><a href="#feedback" id="toc-feedback" class="nav-link" data-scroll-target="#feedback">Feedback</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">MonoPowder</h1>
<p class="subtitle lead">Inclusive Ski Touring</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Authors</div>
    <div class="quarto-title-meta-contents">
             <p>Anna Banzer </p>
             <p>Isotta Bernardoni </p>
             <p>Joël Kocher </p>
             <p>Till Höussner <a href="mailto:thaeussner@ethz.ch" class="quarto-title-author-email"><i class="bi bi-envelope"></i></a> </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">May 13, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="the-problem" class="level1">
<h1>The Problem</h1>
<p>Experienced sitski users may like to ski off-piste, but can only do so with lift access. There is currently no solution for them to overcome flat or uphill sections in the backcountry, except for being towed.</p>
<p>We want to create a solution for independent uphill propulsion to enable sitski users to join their friends on ski tours.</p>
</section>
<section id="our-initial-brainstorming-ideas" class="level1">
<h1>Our Initial Brainstorming Ideas</h1>
<p>How would you propel yourself upwards? We worked out three initial ideas for the propulsion system:</p>
<section id="hand-cycle-setup" class="level2">
<h2 class="anchored" data-anchor-id="hand-cycle-setup">Hand-Cycle Setup</h2>
<p>The idea is to attach a hybrid, electrically assisted hand-cycle system, which is common for wheelchairs, to the sitski. A rubber track would provide tracktion in the snow. The big problem here is the complex attachment and the lack of balance on rougher terrain, hence the need for external stabilization.</p>
<div class="quarto-figure quarto-figure-left">
<figure class="figure">
<p><img src="images/handcycle.png" class="img-fluid figure-img"></p>
<figcaption>The hand-cycle system for wheelchairs, which could be adapted to the sitski.<br>
<em>Source:</em> <a href="https://www.paraplegie.ch/orthotec/en/aids/using-wheelchair/sports-devices/hand-bikes/">EMPULSE Attitude Hybrid</a></figcaption>
</figure>
</div>
<table class="table">
<colgroup>
<col style="width: 47%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Existing systems on the market</td>
<td>Lack of balance and need for external stabilization</td>
</tr>
<tr class="even">
<td>Ergonomic power delivery and hybrid assistance</td>
<td>Bulky system, complex attachment to the sitski</td>
</tr>
</tbody>
</table>
<p><strong>Verdict:</strong> The idea was not pursued further because of better alternatives</p>
</section>
<section id="rod-assisted-tracks" class="level2">
<h2 class="anchored" data-anchor-id="rod-assisted-tracks">Rod-Assisted Tracks</h2>
<p>The idea is to attach big, hybrid tracks underneath the sitski, which are driven by a handheld rod and assiste by an electric motor. Traction would be good, but the power delivery is not as ergonomic and it would also need external stabilization.</p>
<div class="quarto-figure quarto-figure-left">
<figure class="figure">
<p><img src="images/rodassist.png" class="img-fluid figure-img"></p>
<figcaption>Concept render of the rod-assisted tracks. <a href="https://grabcad.com/library/sit-ski-1">Sitski model by Hunter King</a></figcaption>
</figure>
</div>
<table class="table">
<colgroup>
<col style="width: 41%">
<col style="width: 58%">
</colgroup>
<thead>
<tr class="header">
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Good position underneath the sitski</td>
<td>Lack of balance and need for external stabilization</td>
</tr>
<tr class="even">
<td>Less complex system</td>
<td>Power delivery not as ergonomic</td>
</tr>
</tbody>
</table>
<p><strong>Verdict:</strong> The idea was not pursued further because of better alternatives</p>
</section>
<section id="fully-motorized-tracks" class="level2">
<h2 class="anchored" data-anchor-id="fully-motorized-tracks">Fully Motorized Tracks</h2>
<p>The idea is to attach smaller, electrically motorized tracks to the ski for propulsion. The hands would be free to balance, push and steer the sitski with outriggers. The tracks would preferably be placed in front and attached to the sitski frame with ropes, as this is the simplest attachment. The drawback of this would be limited traction, as most of the weight is in the back of the ski, especially when going up a slope.</p>
<div class="quarto-figure quarto-figure-left">
<figure class="figure">
<p><img src="images/motorized.png" class="img-fluid figure-img"></p>
<figcaption>Concept render of the motorized tracks. <a href="https://grabcad.com/library/sit-ski-1">Sitski model by Hunter King</a></figcaption>
</figure>
</div>
<table class="table">
<colgroup>
<col style="width: 52%">
<col style="width: 47%">
</colgroup>
<thead>
<tr class="header">
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Small, relatively simple and easy to attach</td>
<td>Position in front not optimal for traction</td>
</tr>
<tr class="even">
<td>Hand are free for balance, steering and pushing</td>
<td>Not a hybrid system, but fully motorized.</td>
</tr>
</tbody>
</table>
<p><strong>Verdict:</strong> The idea is part of the final solution, as it’s the most viable option.</p>
</section>
<section id="adapted-outriggers" class="level2">
<h2 class="anchored" data-anchor-id="adapted-outriggers">Adapted Outriggers</h2>
<p>For the small, motorized tracks proposed above, the hands would be free for balance, pushing and steering. To make this viable, the plates of the outriggers, which are usually small skis for the downhill, would have to be replaced by snowshoe-like plates to provide traction when pushing and steering. Also, the handle would need to house the actuator and for the motors, which would be in joystick-form to accomodate selectively actuating the two tracks for steering assistance. Optionally, the handle could contain a force sensor to measure the pushing force and couple this to the motor power, similar to how e-bikes operate. For the downhill, the traction plate could be swapped out for the regular ski plate.</p>
<div class="quarto-figure quarto-figure-left">
<figure class="figure">
<p><img src="images/outrigger.png" class="img-fluid figure-img"></p>
<figcaption>Concept render of the rod-assisted tracks</figcaption>
</figure>
</div>
<table class="table">
<colgroup>
<col style="width: 47%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Small, relatively simple and easy to attach</td>
<td>Electronics in the handle</td>
</tr>
<tr class="even">
<td>Full control over the motors with just one thumb</td>
<td>Force sensor for assistance would be hard to implement</td>
</tr>
</tbody>
</table>
<p><strong>Verdict:</strong> The idea is part of the final solution for balance, pushing and steering</p>
</section>
</section>
<section id="our-solution" class="level1">
<h1>Our Solution</h1>
<ul>
<li><p>Two motorized tracks are attached to the front of the ski which tow the monoskibob by two ropes. The ski sits on a plate between the tracks to provide more traction with its weight. The tracks can be slid on and off the front of the ski easily and quickly. The battery for the two electric motors sits on top to weigh down the tracks even more. We estimate that the battery needs to have a capacity of about 500Wh.</p></li>
<li><p>The tracks are actuated via a joystick on the tip of one handle. With sideways motion, the tracks can be selectively actuated to assist with steering. The actuator is connected to the tracks wirelessly to further simplify the system.</p></li>
<li><p>The outriggers are adapted with traction plates on the bottom to enable good traction in the snow for pushing, balancing and steering. The angle on the plate can be adjusted with a pulley system like for the regular downhill outrigger. The traction plates can be swapped out for the regular ski plates for the downhill.</p></li>
<li><p>(Optional) To enable hybrid power delivery similar to an e-bike, the user could assist the motor by pushing the sitski uphill with the outriggers. To smoothly couple the arm assistance to the motor controls, a pressure sensor could be added to the handle of the outriggers to measure the pushing force exerted.</p></li>
</ul>
<div class="quarto-figure quarto-figure-left">
<figure class="figure">
<p><img src="images/final.png" class="img-fluid figure-img"></p>
<figcaption>Concept render of the final solution with the motorized tracks and the adapted outriggers. <a href="https://grabcad.com/library/sit-ski-1">Sitski model by Hunter King</a><em>.</em> <a href="https://grabcad.com/library/articulated-dummy-1">Dummy by Barkfin.</a></figcaption>
</figure>
</div>
</section>
<section id="feedback" class="level1">
<h1>Feedback</h1>
<p>Thank you for the interest in our little project. If you have any questions, ideas or other feedback, we would be happy to hear from you: <a href="https://forms.gle/TSKb428KnsZWrjeY8" class="uri">Link to Google Forms (german)</a></p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>