<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Anna Banzer">
<meta name="author" content="Isotta Bernardoni">
<meta name="author" content="Joël Kocher">
<meta name="author" content="Till Höussner">
<meta name="dcterms.date" content="2024-05-14">

<title>MonoPowder</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


<link rel="stylesheet" href="styles.css">
</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#welches-problem-wollen-wir-lösen" id="toc-welches-problem-wollen-wir-lösen" class="nav-link active" data-scroll-target="#welches-problem-wollen-wir-lösen">Welches Problem wollen wir lösen?</a></li>
  <li><a href="#die-ideen-aus-unserem-brainstorming" id="toc-die-ideen-aus-unserem-brainstorming" class="nav-link" data-scroll-target="#die-ideen-aus-unserem-brainstorming">Die Ideen aus unserem Brainstorming</a>
  <ul class="collapse">
  <li><a href="#handrad-vorrichtung" id="toc-handrad-vorrichtung" class="nav-link" data-scroll-target="#handrad-vorrichtung">Handrad-Vorrichtung</a></li>
  <li><a href="#handgeführte-raupen" id="toc-handgeführte-raupen" class="nav-link" data-scroll-target="#handgeführte-raupen">Handgeführte Raupen</a></li>
  <li><a href="#rein-motorisierte-raupen" id="toc-rein-motorisierte-raupen" class="nav-link" data-scroll-target="#rein-motorisierte-raupen">Rein motorisierte Raupen</a></li>
  <li><a href="#angepasste-outrigger" id="toc-angepasste-outrigger" class="nav-link" data-scroll-target="#angepasste-outrigger">Angepasste Outrigger</a></li>
  </ul></li>
  <li><a href="#our-solution" id="toc-our-solution" class="nav-link" data-scroll-target="#our-solution">Our Solution</a></li>
  <li><a href="#feedback" id="toc-feedback" class="nav-link" data-scroll-target="#feedback">Feedback</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">MonoPowder</h1>
<p class="subtitle lead">Inclusive Ski Touring</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Authors</div>
    <div class="quarto-title-meta-contents">
             <p>Anna Banzer </p>
             <p>Isotta Bernardoni </p>
             <p>Joël Kocher </p>
             <p>Till Höussner <a href="mailto:thaeussner@ethz.ch" class="quarto-title-author-email"><i class="bi bi-envelope"></i></a> </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">May 14, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p><a href="https://thaeussner.github.io/monopowder_en/"><strong><em>English Version</em></strong></a></p>
<section id="welches-problem-wollen-wir-lösen" class="level1">
<h1>Welches Problem wollen wir lösen?</h1>
<p>Erfahrene Fahrer:innen von Monoskibobs können ohne Probleme Routen abseits der Piste befahren.</p>
<p>Der Aufstieg ohne Lift, wie er selbst bei kleinen Variantenfahrten vorkommen kann, ist im Monoskibob bis jetzt jedoch sehr schwierig. Meist müssen Betroffene von der Gruppe aufwendig gezogen werden und/oder sich selbst den Hang hochstossen.</p>
<p>Wir wollen konzeptuell eine neue Lösung für den unabhängigen Aufstieg im Monoskibob erarbeiten, und so einen Beitrag zur Inklusion bei Skitouren- und Variantenfahrten leisten.</p>
</section>
<section id="die-ideen-aus-unserem-brainstorming" class="level1">
<h1>Die Ideen aus unserem Brainstorming</h1>
<p>Wie befördert man sich im Skibob ohne Lift effizient einen Hang hinauf? Wir haben ein mögliche Ideen ausgearbeitet und dann die besten weiterverfolgt:</p>
<section id="handrad-vorrichtung" class="level2">
<h2 class="anchored" data-anchor-id="handrad-vorrichtung">Handrad-Vorrichtung</h2>
<p>Die Idee ist, eine hybride Handrad-Vorrichtung (wie sie für Rollstühle erhältlich ist) vorne an den Skibob anzubringen. Das Rad würde durch eine Gummiraupe ersetzt werden, um möglichst viel Griff im Schnee zu garantieren. Das grosse Problem hierbei wäre die schwierige Befestigung am Skibob und das grosse, komplexe System, sowie der Mangel an Balancemöglichkeiten in unebenem Gelände, was externe Stabilisierung braucht.</p>
<div class="quarto-figure quarto-figure-left">
<figure class="figure">
<p><img src="images/handcycle.png" class="img-fluid figure-img"></p>
<figcaption>Eine Handrad-Vorrichtung für Rollstühle, welche am Skibob befestigt werden würde.<br>
<em>Quelle:</em> <a href="#0">EMPULSE Attitude Hybrid</a></figcaption>
</figure>
</div>
<table class="table">
<colgroup>
<col style="width: 47%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Das System existiert schon auf dem Markt</td>
<td>Fehlende Balancemöglichkeiten</td>
</tr>
<tr class="even">
<td>Ergonomische Kraftübertragung mit hybrider Unterstützung</td>
<td>Komplexes, sperriges System mit schwieriger Befestigung am Skibob.</td>
</tr>
</tbody>
</table>
<p><strong>Entscheid:</strong> Die Idee wurde aufgrund besserer Alternativen nicht weiter verfolgt.</p>
</section>
<section id="handgeführte-raupen" class="level2">
<h2 class="anchored" data-anchor-id="handgeführte-raupen">Handgeführte Raupen</h2>
<p>Die Idee wäre, grosse, motorisierte Raupen unter dem Skibob zu befestigen, welche mit Griffen von Hand geführt und dabei von einem Motor unterstützt werden. Griff im Schnee wäre kein Problem, jedoch ist die Kraftübertragung nicht sehr ergonomisch und auch dieses Design bräuchte externe Stabilisierung.</p>
<div class="quarto-figure quarto-figure-left">
<figure class="figure">
<p><img src="images/rodassist.png" class="img-fluid figure-img"></p>
<figcaption>Konzeptuelles Modell der handgeführten Raupen. <a href="https://grabcad.com/library/sit-ski-1">Sitski-Modell von Hunter King</a></figcaption>
</figure>
</div>
<table class="table">
<thead>
<tr class="header">
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Gute Position unter dem Sitz</td>
<td>Braucht auch externe Stabilisierung</td>
</tr>
<tr class="even">
<td>Weniger Komplexität</td>
<td>Unergonomische Kraftübertragung</td>
</tr>
</tbody>
</table>
<p><strong>Entscheid:</strong> Die Idee wurde aufgrund besserer Alternativen nicht weiter verfolgt.</p>
</section>
<section id="rein-motorisierte-raupen" class="level2">
<h2 class="anchored" data-anchor-id="rein-motorisierte-raupen">Rein motorisierte Raupen</h2>
<p>Die Idee ist, kleinere, rein elektrisch motorisierte Raupen am Ski zu befestigen. Die Hände wären somit frei für die Stabilisierung, Balance und Steuerung mit angepassten Outriggern. Die Raupen würden am vorderen Teil des Skis befestigt und wären mit Seilen mit dem Skibob verbunden, da dies einfacher als eine Anbringung hinten wäre. Ein Nachteil dabei ist der mangelhafte Griff im Schnee, vor allem bei steileren Anstiegen.</p>
<div class="quarto-figure quarto-figure-left">
<figure class="figure">
<p><img src="images/motorized.png" class="img-fluid figure-img"></p>
<figcaption>Konzeptuelles Modell der motorisierten Raupen. <a href="https://grabcad.com/library/sit-ski-1">Sitski-Modell von Hunter King</a></figcaption>
</figure>
</div>
<table class="table">
<colgroup>
<col style="width: 52%">
<col style="width: 47%">
</colgroup>
<thead>
<tr class="header">
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Klein und einfach anzubringen</td>
<td>Befestung vorne nicht optimal für den Griff im Schnee</td>
</tr>
<tr class="even">
<td>Die Hände sind frei für Balance und Steuerung</td>
<td>Kein Hybridsystem, da völlig motorisiert</td>
</tr>
</tbody>
</table>
<p><strong>Entscheid:</strong> Die Idee ist Teil der finalen Lösung.</p>
</section>
<section id="angepasste-outrigger" class="level2">
<h2 class="anchored" data-anchor-id="angepasste-outrigger">Angepasste Outrigger</h2>
<p>For the small, motorized tracks proposed above, the hands would be free for balance, pushing and steering. To make this viable, the plates of the outriggers, which are usually small skis for the downhill, would have to be replaced by snowshoe-like plates to provide traction when pushing and steering. Also, the handle would need to house the actuator and for the motors, which would be in joystick-form to accomodate selectively actuating the two tracks for steering assistance. Optionally, the handle could contain a force sensor to measure the pushing force and couple this to the motor power, similar to how e-bikes operate. For the downhill, the traction plate could be swapped out for the regular ski plate.</p>
<div class="quarto-figure quarto-figure-left">
<figure class="figure">
<p><img src="images/outrigger.png" class="img-fluid figure-img"></p>
<figcaption>Concept render of the rod-assisted tracks</figcaption>
</figure>
</div>
<table class="table">
<colgroup>
<col style="width: 47%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Small, relatively simple and easy to attach</td>
<td>Electronics in the handle</td>
</tr>
<tr class="even">
<td>Full control over the motors with just one thumb</td>
<td>Force sensor for assistance would be hard to implement</td>
</tr>
</tbody>
</table>
<p><strong>Verdict:</strong> The idea is part of the final solution for balance, pushing and steering</p>
</section>
</section>
<section id="our-solution" class="level1">
<h1>Our Solution</h1>
<ul>
<li><p>Two motorized tracks are attached to the front of the ski which tow the monoskibob by two ropes. The ski sits on a plate between the tracks to provide more traction with its weight. The tracks can be slid on and off the front of the ski easily and quickly. The battery for the two electric motors sits on top to weigh down the tracks even more. We estimate that the battery needs to have a capacity of about 500Wh.</p></li>
<li><p>The tracks are actuated via a joystick on the tip of one handle. With sideways motion, the tracks can be selectively actuated to assist with steering. The actuator is connected to the tracks wirelessly to further simplify the system.</p></li>
<li><p>The outriggers are adapted with traction plates on the bottom to enable good traction in the snow for pushing, balancing and steering. The angle on the plate can be adjusted with a pulley system like for the regular downhill outrigger. The traction plates can be swapped out for the regular ski plates for the downhill.</p></li>
<li><p>(Optional) To enable hybrid power delivery similar to an e-bike, the user could assist the motor by pushing the sitski uphill with the outriggers. To smoothly couple the arm assistance to the motor controls, a pressure sensor could be added to the handle of the outriggers to measure the pushing force exerted.</p></li>
</ul>
<div class="quarto-figure quarto-figure-left">
<figure class="figure">
<p><img src="images/final.png" class="img-fluid figure-img"></p>
<figcaption>Concept render of the final solution with the motorized tracks and the adapted outriggers. <a href="https://grabcad.com/library/sit-ski-1">Sitski model by Hunter King</a><em>.</em> <a href="https://grabcad.com/library/articulated-dummy-1">Dummy by Barkfin.</a></figcaption>
</figure>
</div>
</section>
<section id="feedback" class="level1">
<h1>Feedback</h1>
<p>Thank you for the interest in our little project. If you have any questions, ideas or other feedback, we would be happy to hear from you: <a href="https://forms.gle/TSKb428KnsZWrjeY8" class="uri">Link to Google Forms (german)</a></p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>